generate_continuousT_training <- function(seed, size, uncertaintyW, w1, w2){
  # Generate simulation datasets
  # Parameters:
  # -- seed: set random number generator
  # -- size: sample size
  # -- uncertaintyW: the variability of heterogeneous variables
  # -- w1, w2: weights
  # Output: data frame consists of four heterogeneous variables (H1, H2, H3, H4),
  #         treatment value A, and response Y1
  D <- DAG.empty()
  D <- D +
    node("H1",
         distr = "runif",
         min = 0, max=1) +
    node("H2",
         distr = "runif",
         min = 0, max=1) +
    node("H3",
         distr = "runif",
         min = 0, max=0) +
    node("H4",
         distr = "runif",
         min = 0, max=0) +
    node("A",
       distr = "rbern",
      prob = plogis(-0.5 - 0.3 * H1 - 0.3 * H2)) +
    node("U.Y",
         distr = "rnorm",
         mean = 0,
         sd = uncertaintyW) +
  node("Y1",
       distr = "rnorm",
       mean =  ifelse( A <= 0.3 & A>0, 5*((2/(1+exp(-12*(H1-0.2))))*(2/(1+exp(-12*(H2-0.2))))-2) + U.Y, 
                       ifelse( A <= 0.5 & A>0.3 , -5*((2/(1+exp(-12*(H1-0.2))))*(2/(1+exp(-12*(H2-0.2))))-2) + U.Y,
                              ifelse(A <= 0.7 & A>0.5, 1*((2/(1+exp(-12*(H1-0.2))))*(2/(1+exp(-12*(1-H2-0.2))))-2) + U.Y,
                                     ifelse(A <= 1& A>0.7,-1*((2/(1+exp(-12*(H1-0.2))))*(2/(1+exp(-12*(1-H2-0.2))))-2) + U.Y, 
                                            U.Y)))),
       sd = 0)
  Dset <- set.DAG(D, latent.v = c("U.Y"))
  
  A1 <- node("A", distr = "runif", min = 0, max = 1)
  Dset <- Dset + action("A1", nodes = A1)
  A0 <- node("A", distr = "rbern", prob = 0)
  Dset <- Dset + action("A0", nodes = A0)
  
  Xdat1 <- sim(DAG = Dset, actions = c("A1", "A0"), n = size, rndseed = seed)
  return(rbind(Xdat1[["A1"]], Xdat1[["A0"]]))
}


meanFun <- function(Hvec,A)
{
  H1 <- Hvec$H1
  H2 <- Hvec$H2
  H3 <- Hvec$H3
  H4 <- Hvec$H4
  
  simuFun <- function(x)
  {
    return(2/(1+exp(-12*(x-0.2))))
  }
  
  meanY <- sapply(1:length(A), 
                  function(i)
                  {
                    if(A[i] == 0) return(0)
                    else if (A[i] <= 0.3 & A[i]>0 ) return(5*(simuFun(H1[i])*simuFun(H2[i])-2))
                    else if (A[i] <= 0.5 & A[i]>0.3) return(-5*(simuFun(H1[i])*simuFun(H2[i])-2))
                    else if (A[i] <= 0.7 & A[i]>0.5) return(1*(simuFun(H1[i])*simuFun(1-H2[i])-2))
                    else return(-1*(simuFun(H1[i])*simuFun(1-H2[i])-2))
                  }
  )
  return(meanY)
}



process_nonbinary_treatment <- function(data)
{
  # Process the data generated by createCasualDAG and prepare for training&testing
  # Parameters:
  # -- data: data frame generated by createCasualDAG()
  # Output: processed data by separating A to be A = Z*treatment;
  data <- data.frame(data)
  treatment = as.numeric(data$A != 0)
  Z = data$A
  id = which(treatment == 0)
  # Z[id] <- rcat.b1(length(id), prob=c(0.25,0.25,0.25))
  Z[id] <- sample(Z[which(treatment!= 0)], size = length(id), replace = TRUE)
  return(data.frame(data, treatment, Z))
}


estimatedTreatmentEffect <- function(Data, optimalZ_for_Xcohorts)
{
  numCohort <- length(optimalZ_for_Xcohorts)
  dataList = lapply(1:nrow(Data), function(i) Data[i,])
  findCohort <- t(mapply(whichCohort, dataList, list(optimalZ_for_Xcohorts),
                         list(isFeaturesCategorical)))

  get_estimated_treatment_effect_continuousT <- function(sampleId)
  {
    cohortId <- findCohort[sampleId]
    Avalue <- Data[sampleId, 'A']
    currCohort <- optimalZ_for_Xcohorts[[cohortId]]
  }
  
}

## evaluation of non-binary causal tree
ATE_at_optimalZ_continuousT_testing <- function(givenH, optimalZ_for_Xcohorts, 
                                         isFeaturesCategorical)
{
  Ntest <- dim(givenH)[1]
  numCohort <- length(optimalZ_for_Xcohorts)
  dataList = lapply(1:nrow(givenH), function(i) givenH[i,])
  findCohort <- t(mapply(whichCohort, dataList, list(optimalZ_for_Xcohorts),
                         list(isFeaturesCategorical)))
  get_optimal_treatment_continuousT <- function(cohortId, optimalZ_for_Xcohorts)
  {
    optimalCausalEffect <- optimalZ_for_Xcohorts[[cohortId]]$optimalCausalEffect
    if(optimalCausalEffect <= 0) {return(0)}
    else{
      optimalZRange <- optimalZ_for_Xcohorts[[cohortId]]$optimalZregion$Z
      Treatment <- runif(1, min = optimalZRange['lower'], max = optimalZRange['upper'])
      return(Treatment)
    }
  }
  treatmentForTesting <- mapply(get_optimal_treatment_continuousT, findCohort, list(optimalZ_for_Xcohorts))
  A <- treatmentForTesting
  U.Y <- rnorm(Ntest, mean = 0, sd = uncertaintyW)
  Y <- meanFun(givenH, A) + U.Y
  return(mean(Y))
}

## evaluation of binary causal tree
ATE_binary_CT_continuousT_testing <- function(givenH, Xcohorts_binary, 
                                                isFeaturesCategorical)
{
  Ntest <- dim(givenH)[1]
  numCohort <- length(Xcohorts_binary)
  dataList = lapply(1:nrow(givenH), function(i) givenH[i,])
  findCohort <- t(mapply(whichCohort, dataList, list(Xcohorts_binary),
                         list(isFeaturesCategorical)))
  
  get_optimal_treatment_binary_continuousT <- function(cohortId, Xcohorts_binary)
  {
    optimalCausalEffect <- Xcohorts_binary[[cohortId]]$causalEffect
    if(optimalCausalEffect <= 0) {return(0)}
    else{
      Zrange <- get_feature_range(Z, allFeatureRanges)
      Treatment <- runif(1, min = Zrange['lower'], max = Zrange['upper'])
      return(Treatment)
    }
  }
  
  treatmentForTesting <- mapply(get_optimal_treatment_binary_continuousT,
                                findCohort, list(Xcohorts_binary))
  A <- treatmentForTesting
  U.Y <- rnorm(Ntest, mean = 0, sd = uncertaintyW)
  Y <- meanFun(givenH, A) + U.Y
  return(mean(Y))
}

whichCohort <- function(sample, cohortsList, isFeaturesCategorical)
{
  # determine which Xcohort the given sample is in and report its optimal treatment
  # by assigning it to the optimal treatment level
  # Parameters:
  # -- sample: vector of information for one give sample
  # -- optimalZ_for_Xcohorts: a list consisting of information of estimated causal effects
  #                           wrt different treatment level Z for each X cohort
  # -- isFeaturesCategorical: a vector indicating if the features are categorical
  # Output: a vector consisting of the cohortId which this sample belongs to
  #         together with the optimal treatment effect in this cohort
  varsOfInterest <- names(cohortsList[[1]]$cohortRegion)
  for(cohortId in 1:length(cohortsList))
  {
    currCohort <- cohortsList[[cohortId]]
    flag <-  all(sapply(1:length(varsOfInterest), function(varId) {
      feature <- varsOfInterest[varId]
      if(get_feature_type(feature, isFeaturesCategorical))
      {return(sample[feature] %in% currCohort$cohortRegion[[varId]])}
      else
      {return(sample[feature] >= currCohort$cohortRegion[[varId]]['lower'] &&
                sample[feature] <= currCohort$cohortRegion[[varId]]['upper'])}
    }))
    if(flag) return(c(cohortId = cohortId))
  }
}


## Estimation Accuracy
groundTruthTreatmentEffect <- function(Data)
{
  Hvec = Data[, c('H1', 'H2', 'H3', 'H4')]
  A = Data[, 'A']
  trueEffect <- meanFun(Hvec, A)
  return(trueEffect)
}


